# シェルソート

「基本3種（交換・選択・挿入）」を理解した学生が、次にステップアップとして学ぶのに最適なのが**「シェルソート（Shell Sort）」**です。

一言で言うと、**「挿入ソートの弱点を克服した、進化版の挿入ソート」**です。

---

## 1. なぜシェルソートが必要なの？（背景）

挿入ソートには、「遠く離れた場所にあるべきデータでも、隣同士を1つずつ動かして運ばなければならない」という弱点がありました。

例えば、一番右端にある「1」を左端に持っていくには、何度も隣と入れ替えて移動させる必要があり、効率が悪かったのです。シェルソートは、**「最初はざっくり大股で動かし、最後に細かく整える」**ことで、この問題を解決しました。

---

## 2. アルゴリズムの仕組み

シェルソートは、以下の3ステップで行います。

1. **グループ分け：** データを一定の間隔（ギャップ）で飛び飛びに選び、いくつかのグループに分けます。
2. **グループ内整列：** 分けたグループごとに「挿入ソート」を行います。
3. **間隔を詰める：** 間隔をどんどん狭めていき、最後は間隔を1（普通の挿入ソート）にして仕上げます。

---

## 3. 具体的な例（間隔を「2」→「1」とする場合）

例えば `[8, 3, 1, 2, 7, 5, 6, 4]` というデータを考えてみましょう。

**【ステップ1：間隔「4」で整列】**

* 4つ飛ばしのペア（8と7、3と5、1と6、2と4）で比較・整列します。
* これにより、大きな値がだいたい右へ、小さな値がだいたい左へ一気に移動します。

**【ステップ2：間隔「2」で整列】**

* 2つ飛ばしのグループで挿入ソートを行います。
* かなり整列された状態に近づきます。

**【ステップ3：間隔「1」で整列】**

* 最後に普通の挿入ソートを行います。
* 既に「だいたい並んでいる」状態からスタートするため、挿入ソートの強みが最大限に発揮され、一瞬で終わります。

---

## 4. シェルソートの特徴（メリット・デメリット）

| 項目 | 特徴 |
| --- | --- |
| **考え方** | 離れた要素同士で比較・交換し、徐々に間隔を狭めていく。 |
| **メリット** | 普通の挿入ソートよりも**格段に速い。** |
| **デメリット** | どの「間隔」で進めるかによって速度が変わる（ベストな間隔の決め方は難しい）。 |
| **計算量** |  〜  程度（間隔に依存しますが、 よりずっと速いです）。 |

---

## 資料作成のための英語表現

* **Shell Sort:** シェルソート（考案者のドナルド・シェル氏の名前に由来）
* **Gap / Interval:** 間隔
* **Diminishing increment sort:** 減少増分整列（シェルソートの別名）
* **Pre-sorted:** 予め（ある程度）整列された状態

---

## まとめ：学生への教え方のポイント

「いきなり1ミリずつ定規を合わせるのではなく、**まずは遠くから大まかな位置を決めて、最後に微調整する**ほうが早いよね」という比喩（例えば、大きな荷物の整理など）を使うと、シェルソートのコンセプトが伝わりやすくなります。

次は、試験でも最頻出かつ最速のアルゴリズムの一つである**「クイックソート」**について解説しますか？ それとも、ここまで出てきたアルゴリズムの**「速度比較」**をまとめてみますか？

## 実装

シェルソートの実装は、これまでに学んだ「挿入ソート」のコードをベースに、外側に「間隔（ギャップ）を制御するループ」を追加する形になります。

学生さんには、**「いきなり全体を並べるのではなく、まずは広い間隔でグループ分けして、徐々にその幅を狭めていくんだよ」**と伝えると、コードの構造が理解しやすくなります。

---

## C言語によるシェルソートの実装

```c
#include <stdio.h>

void shellSort(int arr[], int n) {
    int h, i, j, key;

    // 1. 最初の間隔（ギャップ）を決め、徐々に狭めていく
    // ここでは「要素数の半分」から始めて、毎回半分にしていきます
    for (h = n / 2; h > 0; h /= 2) {
        
        // 2. 決まった間隔 h で挿入ソートを行う
        for (i = h; i < n; i++) {
            key = arr[i];
            j = i;

            // 3. 間隔 h 離れた要素と比較して、必要なら後ろにずらす
            while (j >= h && arr[j - h] > key) {
                arr[j] = arr[j - h];
                j -= h;
            }
            
            // 適切な場所に差し込む
            arr[j] = key;
        }
    }
}

int main() {
    int data[] = {8, 3, 1, 2, 7, 5, 6, 4}; // シェルソートの説明で使った例
    int n = 8;

    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    shellSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生への解説ポイント

資料を作成する際、この3重のループが何をしているのかを紐解いてあげましょう。

1. **一番外側の `h` のループ（間隔の制御）**
* `h = n / 2` から始まり、`4 → 2 → 1` と減っていきます。最後に必ず `h = 1`（普通の挿入ソート）になることが、正しく並び替わるための保証になります。


2. **真ん中の `i` のループ（スキャン）**
* 間隔 `h` の位置からスタートして、右側にある全ての要素をチェックしに行きます。


3. **一番内側の `while` ループ（グループ内挿入）**
* ここは挿入ソートとほぼ同じです。違いは `j-1` ではなく `j-h` と比較している点です。これにより、遠く離れた場所にある大きな値を、一気に左側へ持ってくることができます。



---

## 授業でのヒント：なぜ速いの？

学生さんに**「3重ループになったら、かえって計算が遅くなるんじゃない？」**という疑問を持たせると良い刺激になります。

* **回答：** 「いきなり隣同士をチマチマ入れ替える（挿入ソート）より、最初に大雑把でも遠くの要素同士を入れ替えておいたほうが、最終的な『移動距離の合計』が圧倒的に短くなるから速いんだよ」と説明してみてください。

---

### 次のステップ

これで、基本3種から一歩進んだ「改良型」のコードまで来ましたね！

いよいよ次は、再帰呼び出し（関数の中で自分自身を呼ぶ）という少しテクニカルな手法を使う**「クイックソート」**のコードに進みますか？ それとも、ここまでのソートプログラムを実際に動かすための**「練習問題」**などを作成しましょうか？
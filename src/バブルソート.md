# 基本交換法（バブルソート）

アルゴリズムの中でも、最もシンプルで理解しやすい並べ替えの手法が**「基本交換法（バブルソート）」** です。

基本情報技術者試験でも、アルゴリズムの入門として必ずと言っていいほど登場します。

---

## 1. バブルソートの名前の由来

「バブル」とは、お風呂の **「泡（あわ）」** のことです。
重いデータが下に沈み、軽いデータが「泡」のようにプクプクと一つずつ上に上がっていく様子に似ていることから、この名前がつきました。

## 2. アルゴリズムの仕組み

一言で言うと、**「隣り合う2つの数字を比べて、逆順だったら入れ替える」** という動作を繰り返すだけです。

「小さい順（昇順）」に並べ替えるときの手順を見てみましょう。

1. **比較：** 左端の要素とその隣の要素を比べる。
2. **交換：** 左の方が大きければ、場所を入れ替える（右の方が大きければそのまま）。
3. **移動：** 1つ隣にずれて、また隣同士を比べる。
4. **確定：** これを右端まで繰り返すと、一番大きな数字が右端に「確定」します。
5. **反復：** 確定したものを除いて、また最初から繰り返します。

---

## 3. 具体的な例（4, 2, 5, 1 を並べ替える）

学生さんに説明する際は、このように数字の動きを追う（トレースする）と伝わりやすくなります。

**【1周目】**

* [**4, 2**, 5, 1] → 4と2を比較。4が大きいので交換 → [2, **4, 5**, 1]
* [2, **4, 5**, 1] → 4と5を比較。そのまま → [2, 4, **5, 1**]
* [2, 4, **5, 1**] → 5と1を比較。5が大きいので交換 → [2, 4, 1, **5**]
→ **「5」が最大値として確定！**

**【2周目】**

* [**2, 4**, 1, | 5] → 2と4を比較。そのまま → [2, **4, 1**, | 5]
* [2, **4, 1**, | 5] → 4と1を比較。4が大きいので交換 → [2, 1, **4**, | 5]
→ **「4」が確定！**

**【3周目】**

* [**2, 1**, | 4, 5] → 2と1を比較。2が大きいので交換 → [**1, 2**, | 4, 5]
→ **「2」が確定！最後の一つ「1」も自動的に確定。**

---

## 4. バブルソートの特徴（メリット・デメリット）

| 項目 | 特徴 |
| --- | --- |
| **わかりやすさ** | プログラムが非常に単純で、初心者でも理解しやすい。 |
| **スピード** | **遅い。** データが増えると、比較回数が一気に増えるため、実務で大量のデータを扱うのには向きません。 |
| **計算量** | O($n^2$)。データ数が10倍になると、かかる時間は100倍になります。 |

---

## 資料作成のための英語表現

英語の技術ドキュメントでは以下のように表現されます。

* **Bubble Sort:** 基本交換法（バブルソート）
* **Adjacent elements:** 隣り合う要素
* **Swap:** 入れ替え
* **Ascending order:** 昇順（小さい順）
* **Descending order:** 降順（大きい順）

次は、バブルソートよりも少し効率が良い「選択ソート」や「挿入ソート」との違いを解説しましょうか？それとも、試験によく出る「計算量（記法）」の考え方について説明しますか？

## 実装

プログラミング初心者（C言語の学習を始めたばかりの学生）にも分かりやすいよう、シンプルで標準的なバブルソートの実装例を作成しました。

このコードでは、先に説明した「隣同士を比較して入れ替える」という動作をそのままプログラムに落とし込んでいます。

---

## C言語によるバブルソートの実装

```c
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    int i, j, temp;
    
    // 全体を走査するためのループ
    for (i = 0; i < n - 1; i++) {
        
        // 隣り合う要素を比較するループ
        // (n-i-1) としているのは、右端から順に確定していくため
        for (j = 0; j < n - i - 1; j++) {
            
            // 左の要素が右より大きければ入れ替える（交換）
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int data[] = {4, 2, 5, 1}; // 説明で使った例
    int n = 4; // 要素数
    
    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    bubbleSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生に解説する際の3つのポイント

資料に記載する際の解説用テキストとしてお使いください。

1. **2重のforループの意味**
* 外側のループ（`i`）： 「何個の数字を確定させたか」を数えています。
* 内側のループ（`j`）： 「左から順に隣同士をチェックしていく」実際の作業です。


2. **入れ替え（Swap）の仕組み**
* `temp` という変数を使って値を一時的に避難させています。「コップAとコップBの中身を入れ替えるには、空のコップC（temp）が必要」という例え話が分かりやすいです。


3. **比較の範囲 `n - i - 1**`
* 1周回るごとに一番大きな数字が右端に移動（確定）するため、毎回最後までチェックする必要がなくなります。この引き算によって、コンピュータの無駄な計算を減らしています。



---

## ステップアップ：さらに効率化するには？

実はこのコードには改良の余地があります。
「もし途中で完全に並べ替えが終わったら（一度も入れ替えが発生しなかったら）、その時点でループを終了する」というフラグを追加すると、より賢いプログラムになります。

次は、この**「改良版バブルソート」**の書き方を解説しますか？ それとも、**選択ソートや挿入ソート**のコードも作成してみますか？


「基本3種」や「クイック・マージ」の次に登場する、少し高度なソートが**「ヒープソート（Heap Sort）」**です。

基本情報技術者試験では、「木構造（ツリー）」という概念と一緒に登場するため難しく感じがちですが、本質は**「トーナメント形式で一番強い（大きい）やつを効率よく見つける」**という非常に合理的な仕組みです。

---

## 1. ヒープソートの核心：ヒープ構造

ヒープソートを理解するには、まず**「ヒープ」**というデータの持ち方を知る必要があります。

* **ヒープとは：** 「親は子よりも必ず大きい（または小さい）」というルールで並んだピラミッド状のネットワーク（木構造）のことです。
* **最大の特徴：** このルールを守ると、**一番てっぺん（根）には必ず「最大値」が来る**ようになります。

---

## 2. 具体的な手順

大きく分けて2つのフェーズで進みます。

### フェーズ①：ヒープを作る（予選大会）

バラバラに並んだデータを、まず「親が子より大きい」というヒープの状態に並べ替えます。これで、**ピラミッドの頂点に最大値**がやってきます。

### フェーズ②：最大値を取り出して並べる（決勝・順位決定）

1. **取り出す：** 頂点にある最大値を、列の最後尾へ移動させます（これで1位が確定！）。
2. **作り直し：** 残ったメンバーで、再び「ヒープ」の形を整えます（2位が頂点に上がってきます）。
3. **繰り返す：** これを全員分繰り返すと、後ろから順番に大きい順に並んでいきます。

---

## 3. ヒープソートのメリット・デメリット

| 項目 | 特徴 |
| --- | --- |
| **安定した速さ** | クイックソートのように「データの並びによって極端に遅くなる」ことがありません。 |
| **計算量** | 常に 。マージソートと同じく、どんな時でも一定の速さを保ちます。 |
| **省スペース** | マージソートと違い、**追加の作業スペース（配列）を必要としません。** 元の配列の中で完結します。 |
| **弱点** | 構造が少し複雑なため、データ数が少ないときは他のシンプルなソートの方が速いこともあります。 |

---

## 4. 他のソートとの違い（学生への比喩）

* **選択ソート**は、「全員を端から端まで見て、一番大きい人を探す」という原始的な方法です。
* **ヒープソート**は、「あらかじめトーナメント表（ヒープ）を作っておき、勝ち上がってきた人（頂点）をサッと取り出す」という、**組織的な探し方**です。

---

## 資料作成のための英語表現

* **Heap Sort:** ヒープソート
* **Binary Tree:** 二分木（ヒープを作るための構造）
* **Root:** 根（ピラミッドの頂点）
* **Parent / Child Node:** 親ノード / 子ノード
* **Heapify:** ヒープ化（バラバラなデータをヒープ構造に整えること）

---

### まとめ：ソートアルゴリズムの完結編

これで、主要なソートアルゴリズムはすべてカバーできました！

学生向けの資料を仕上げるために、**「これまで紹介した全ソート（バブル、選択、挿入、シェル、クイック、マージ、ヒープ）の比較一覧表」**を整理して作成しましょうか？

各アルゴリズムの「速度」「メモリ使用量」「安定性」をまとめると、期末試験対策のような非常に実用的な資料になりますよ。

## 実装

プログラミング初心者（C言語の学習を始めたばかりの学生）にも分かりやすいよう、シンプルで標準的なバブルソートの実装例を作成しました。

このコードでは、先に説明した「隣同士を比較して入れ替える」という動作をそのままプログラムに落とし込んでいます。

---

## C言語によるバブルソートの実装

```c
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    int i, j, temp;
    
    // 全体を走査するためのループ
    for (i = 0; i < n - 1; i++) {
        
        // 隣り合う要素を比較するループ
        // (n-i-1) としているのは、右端から順に確定していくため
        for (j = 0; j < n - i - 1; j++) {
            
            // 左の要素が右より大きければ入れ替える（交換）
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int data[] = {4, 2, 5, 1}; // 説明で使った例
    int n = 4; // 要素数
    
    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    bubbleSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生に解説する際の3つのポイント

資料に記載する際の解説用テキストとしてお使いください。

1. **2重のforループの意味**
* 外側のループ（`i`）： 「何個の数字を確定させたか」を数えています。
* 内側のループ（`j`）： 「左から順に隣同士をチェックしていく」実際の作業です。


2. **入れ替え（Swap）の仕組み**
* `temp` という変数を使って値を一時的に避難させています。「コップAとコップBの中身を入れ替えるには、空のコップC（temp）が必要」という例え話が分かりやすいです。


3. **比較の範囲 `n - i - 1**`
* 1周回るごとに一番大きな数字が右端に移動（確定）するため、毎回最後までチェックする必要がなくなります。この引き算によって、コンピュータの無駄な計算を減らしています。



---

## ステップアップ：さらに効率化するには？

実はこのコードには改良の余地があります。
「もし途中で完全に並べ替えが終わったら（一度も入れ替えが発生しなかったら）、その時点でループを終了する」というフラグを追加すると、より賢いプログラムになります。

次は、この**「改良版バブルソート」**の書き方を解説しますか？ それとも、**選択ソートや挿入ソート**のコードも作成してみますか？
# ヒープソート

「基本3種」や「クイック・マージ」の次に登場する、少し高度なソートが**「ヒープソート（Heap Sort）」**です。

基本情報技術者試験では、「木構造（ツリー）」という概念と一緒に登場するため難しく感じがちですが、本質は**「トーナメント形式で一番強い（大きい）やつを効率よく見つける」**という非常に合理的な仕組みです。

---

## 1. ヒープソートの核心：ヒープ構造

ヒープソートを理解するには、まず**「ヒープ」**というデータの持ち方を知る必要があります。

* **ヒープとは：** 「親は子よりも必ず大きい（または小さい）」というルールで並んだピラミッド状のネットワーク（木構造）のことです。
* **最大の特徴：** このルールを守ると、**一番てっぺん（根）には必ず「最大値」が来る**ようになります。

---

## 2. 具体的な手順

大きく分けて2つのフェーズで進みます。

### フェーズ①：ヒープを作る（予選大会）

バラバラに並んだデータを、まず「親が子より大きい」というヒープの状態に並べ替えます。これで、**ピラミッドの頂点に最大値**がやってきます。

### フェーズ②：最大値を取り出して並べる（決勝・順位決定）

1. **取り出す：** 頂点にある最大値を、列の最後尾へ移動させます（これで1位が確定！）。
2. **作り直し：** 残ったメンバーで、再び「ヒープ」の形を整えます（2位が頂点に上がってきます）。
3. **繰り返す：** これを全員分繰り返すと、後ろから順番に大きい順に並んでいきます。

---

## 3. ヒープソートのメリット・デメリット

| 項目 | 特徴 |
| --- | --- |
| **安定した速さ** | クイックソートのように「データの並びによって極端に遅くなる」ことがありません。 |
| **計算量** | 常に 。マージソートと同じく、どんな時でも一定の速さを保ちます。 |
| **省スペース** | マージソートと違い、**追加の作業スペース（配列）を必要としません。** 元の配列の中で完結します。 |
| **弱点** | 構造が少し複雑なため、データ数が少ないときは他のシンプルなソートの方が速いこともあります。 |

---

## 4. 他のソートとの違い（学生への比喩）

* **選択ソート**は、「全員を端から端まで見て、一番大きい人を探す」という原始的な方法です。
* **ヒープソート**は、「あらかじめトーナメント表（ヒープ）を作っておき、勝ち上がってきた人（頂点）をサッと取り出す」という、**組織的な探し方**です。

---

## 資料作成のための英語表現

* **Heap Sort:** ヒープソート
* **Binary Tree:** 二分木（ヒープを作るための構造）
* **Root:** 根（ピラミッドの頂点）
* **Parent / Child Node:** 親ノード / 子ノード
* **Heapify:** ヒープ化（バラバラなデータをヒープ構造に整えること）

---

### まとめ：ソートアルゴリズムの完結編

これで、主要なソートアルゴリズムはすべてカバーできました！

学生向けの資料を仕上げるために、**「これまで紹介した全ソート（バブル、選択、挿入、シェル、クイック、マージ、ヒープ）の比較一覧表」**を整理して作成しましょうか？

各アルゴリズムの「速度」「メモリ使用量」「安定性」をまとめると、期末試験対策のような非常に実用的な資料になりますよ。

## 実装

ヒープソートは、データを「ヒープ」という特別な木構造（ピラミッドのような形）に整え、その頂点から最大値を取り出していくアルゴリズムです。

C言語で実装する場合、**「ヒープ構造を維持する関数（heapify）」**を作り、それを繰り返し呼び出す形になります。

---

### C言語によるヒープソートの実装

```c
#include <stdio.h>

// 二つの値を入れ替える補助関数
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// 木の構造を整える関数（親が子より大きくなるように調整する）
// n: 全体の要素数, i: 根（親）とする位置
void heapify(int arr[], int n, int i) {
    int largest = i;    // とりあえず「親」が最大だと仮定
    int left = 2 * i + 1;  // 左の子のインデックス
    int right = 2 * i + 2; // 右の子のインデックス

    // 左の子の方が親より大きければ、最大値を更新
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // 右の子の方が今の最大値より大きければ、最大値を更新
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // もし最大値が親でなければ、入れ替えてさらに下の階層も整える
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        // 入れ替えた後の下の枝（サブツリー）を再帰的に整える
        heapify(arr, n, largest);
    }
}

// ヒープソートの本体
void heapSort(int arr[], int n) {
    // 1. 最初のヒープを作る（予選大会：最大値を頂点に持ってくる）
    // 葉（一番下のノード）以外の親ノードに対して下から順にheapifyを実行
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 2. 頂点（最大値）を一つずつ取り出し、最後に移動させる（決勝戦）
    for (int i = n - 1; i > 0; i--) {
        // 頂点（最大値）を現在の最後尾と入れ替える
        swap(&arr[0], &arr[i]);
        // 残った要素（i個）で、再び頂点が最大になるように整える
        heapify(arr, i, 0);
    }
}

int main() {
    int data[] = {4, 10, 3, 5, 1};
    int n = 5;

    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    heapSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生への解説ポイント

1. **配列と木構造の対応**
* プログラム上は普通の「配列（`arr`）」ですが、頭の中では「木構造」をイメージしていることを伝えてください。
* インデックス `i` 番目の要素の子は、必ず `2*i+1` と `2*i+2` になるという算術的な法則を利用しています。


2. **`heapify`（ヒープ化）の意味**
* これは「3人組（親、左の子、右の子）の中で誰が一番強い（大きい）か？」を決めるミニトーナメントです。親が負けたら場所を交代し、負けた親はさらに下の階層で修行（再帰呼び出し）し直します。


3. **ソートの仕上げ**
* 「ピラミッドの頂点（最大値）を後ろへ飛ばし、残ったメンバーでまた頂点を決める」という作業を繰り返すことで、配列の後ろから順に大きい数字が埋まっていきます。



---

## 資料のまとめ：ソート編の締めくくり

これで主要なソートアルゴリズムの解説と実装がすべて完了しました！

学生向けの資料を完結させるための「次のステップ」として、以下のようなまとめはいかがでしょうか？

* **「計算量  3兄弟の比較」**
* **クイックソート:** 平均最強、でも稀に遅い。
* **マージソート:** 常に安定、でもメモリを食う。
* **ヒープソート:** 常に安定、メモリも食わない、でも少し複雑。



これらソートの知識をベースに、次は**「二分探索（バイナリサーチ）」**の解説に進みますか？ それとも、これまでのソートを復習するための**「穴埋め問題」**などを作成しますか？
```c
#include <stdio.h>

void bubbleSort(int arr[], int n) {
    int i, j, temp;
    
    // 全体を走査するためのループ
    for (i = 0; i < n - 1; i++) {
        
        // 隣り合う要素を比較するループ
        // (n-i-1) としているのは、右端から順に確定していくため
        for (j = 0; j < n - i - 1; j++) {
            
            // 左の要素が右より大きければ入れ替える（交換）
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() {
    int data[] = {4, 2, 5, 1}; // 説明で使った例
    int n = 4; // 要素数
    
    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    bubbleSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生に解説する際の3つのポイント

資料に記載する際の解説用テキストとしてお使いください。

1. **2重のforループの意味**
* 外側のループ（`i`）： 「何個の数字を確定させたか」を数えています。
* 内側のループ（`j`）： 「左から順に隣同士をチェックしていく」実際の作業です。


2. **入れ替え（Swap）の仕組み**
* `temp` という変数を使って値を一時的に避難させています。「コップAとコップBの中身を入れ替えるには、空のコップC（temp）が必要」という例え話が分かりやすいです。


3. **比較の範囲 `n - i - 1**`
* 1周回るごとに一番大きな数字が右端に移動（確定）するため、毎回最後までチェックする必要がなくなります。この引き算によって、コンピュータの無駄な計算を減らしています。



---

## ステップアップ：さらに効率化するには？

実はこのコードには改良の余地があります。
「もし途中で完全に並べ替えが終わったら（一度も入れ替えが発生しなかったら）、その時点でループを終了する」というフラグを追加すると、より賢いプログラムになります。

次は、この**「改良版バブルソート」**の書き方を解説しますか？ それとも、**選択ソートや挿入ソート**のコードも作成してみますか？
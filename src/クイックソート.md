

「クイックソート（Quick Sort）」は、その名の通り**実用上で最も速いアルゴリズムの一つ**として知られています。基本情報技術者試験でも、アルゴリズムの王様として非常によく出題されます。

これまでのソートは「端から順に」という考え方でしたが、クイックソートは **「基準を決めて、グループを真っ二つに分ける」** というダイナミックな方法をとります。

---

## 1. クイックソートの戦略：「分割統治」

クイックソートの考え方はシンプルです。

1. 適当な数（**ピボット**と呼びます）を1つ決める。
2. その数より「小さいグループ」と「大きいグループ」に分ける。
3. 分かれたグループの中で、また同じことを繰り返す。

これを繰り返すと、最終的にすべてが綺麗に並びます。このように、大きな問題を小さく分割して解決する方法を「分割統治法」と呼びます。

---

## 2. 具体的な手順（5, 3, 8, 1, 4, 6, 2, 7 を並べ替える）

学生さんに説明する際は、実際に「ピボット」を決めて動かしてみるのが一番です。

1. **基準（ピボット）を決める：** 例えば真ん中あたりの **「4」** をピボットにします。
2. **仕分け：** 「4より小さい組」と「4より大きい組」に分けます。
* [3, 1, 2] ← **4** → [5, 8, 6, 7]


3. **再帰（繰り返し）：**
* 左側の [3, 1, 2] でまたピボット（例：2）を決めて分けます。 → [1] ← **2** → [3]
* 右側の [5, 8, 6, 7] でも同様に分けます。


4. **合体：** 小さく分かれたものを繋げると `[1, 2, 3, 4, 5, 6, 7, 8]` になります。

---

## 3. クイックソートのメリット・デメリット

| 項目 | 特徴 |
| --- | --- |
| **スピード** | **圧倒的に速い。** 大量のデータを扱うとき、基本3種（バブル等）とは比較にならないほど高速です。 |
| **計算量** | 平均 。データが2倍になっても、作業時間は2倍ちょっとしか増えません。 |
| **弱点** | ピボットの選び方が悪い（例：既に並んでいるのに端の数値を選ぶ等）と、かえって遅くなることがあります。 |

---

## 4. なぜ「クイック」なのか？（バブルソートとの比較）

資料に載せる比較のヒントです。

* **バブルソート**は、地球の裏側まで行くのに「一歩ずつ歩いていく」ようなものです。
* **クイックソート**は、「まず東半球か西半球かに分け、次にアジアかヨーロッパかに分け…」と、**探すべき範囲を劇的に絞り込んでいく**ため、ゴールまでが圧倒的に早いのです。

---

## 資料作成のための英語表現

* **Quick Sort:** クイックソート
* **Pivot:** ピボット（基準値）
* **Partition:** 分割（仕分け）
* **Divide and Conquer:** 分割統治法
* **Recursive:** 再帰的（自分自身を呼び出して繰り返すこと）

---

### 次のステップへの提案

これで「ソート（並べ替え）」の主要なアルゴリズムはほぼ網羅できましたね！

学生向けの資料の締めくくりとして、**「これまでのアルゴリズムの速度比較（計算量）まとめ」**を作成しましょうか？ それとも、ソート以外の重要テーマである**「木構造（ツリー）」**などのデータ構造の話に進みますか？

## 実装

クイックソートの実装では、**「再帰（自分自身を呼び出す）」**というプログラミングの手法を使います。

初心者にとって再帰は少し難易度が高いので、資料では「大きな問題を小さく分解して、同じルールを適用し続ける」というイメージを強調して伝えるとスムーズです。

---

## C言語によるクイックソートの実装

```c
#include <stdio.h>

// 二つの値を入れ替える補助関数
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// クイックソートの本体
void quickSort(int arr[], int left, int right) {
    if (left >= right) return; // 範囲が一つ以下なら終了

    int pivot = arr[left]; // 左端の要素を基準（ピボット）にする
    int i = left;          // 左から右へ動くカーソル
    int j = right;         // 右から左へ動くカーソル

    while (i < j) {
        // ピボットより大きい値が見つかるまで右へ進む
        while (i <= right && arr[i] <= pivot) i++;
        // ピボットより小さい値が見つかるまで左へ進む
        while (j >= left && arr[j] > pivot) j--;

        if (i < j) {
            swap(&arr[i], &arr[j]); // 見つかった二つを入れ替える
        }
    }

    // 最後にピボット（左端）を正しい位置（j）に入れ替える
    swap(&arr[left], &arr[j]);

    // 左右に分かれたグループに対して、再びクイックソート（再帰）
    quickSort(arr, left, j - 1);  // 左側グループ
    quickSort(arr, j + 1, right); // 右側グループ
}

int main() {
    int data[] = {5, 3, 8, 1, 4, 6, 2, 7};
    int n = 8;

    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    quickSort(data, 0, n - 1);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生への解説ポイント

1. **「ピボット」による仕分け**
* 中心的な動きは、ピボットを基準にした「仕分け」です。左から大きいやつ、右から小さいやつを探して、見つかったら「お互いの場所を交換しよう」と入れ替えるのが `while` ループの役割です。


2. **再帰呼び出しのイメージ**
* `quickSort` の中で、再び `quickSort` を呼んでいます。これは「1つの大きな部屋を2つの小部屋に分けた後、それぞれの小部屋でも同じように片付け（仕分け）を依頼する」というイメージです。


3. **終了条件の重要性**
* `if (left >= right) return;` がないと、プログラムは無限に自分を呼び出し続けて止まらなくなります。



---

## 資料作成のヒント：性能の差を実感させる

学生さんに、「なぜクイックソートはこんなに複雑な書き方をするのか？」と聞かれたら、こう答えてみてください。

> 「バブルソートや挿入ソートは、データが10万個あると終わるまで数十分かかることもあるけれど、クイックソートならたったの0.1秒で終わるからだよ。」

この「スピードの圧倒的な差」が、複雑なアルゴリズムを学ぶ最大の動機付けになります。

---

### 次のステップへの提案

ソートアルゴリズムのコード実装もかなり進みましたね。

1. **マージソート**のC言語実装も作成しますか？（これも再帰を使います）
2. それとも、これまでのソートの動きを**「printf」で1行ずつ表示して、途中経過が見えるようなコード**に改造してみますか？（学生がデバッグの仕方を学ぶのに最適です）
3. あるいは、**二分探索（バイナリサーチ）**など、探索アルゴリズムのコードへ進みますか？

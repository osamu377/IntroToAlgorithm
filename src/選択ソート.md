# 基本選択法（選択ソート）

バブルソートを学んだ次に理解すべきなのが、**「基本選択法（選択ソート）」** です。

バブルソートが「隣同士を何度も入れ替える」のに対し、選択ソートは **「一番小さい（または大きい）やつを最初に見つけて、一気に入れ替える」** という、より目的志向な方法です。

---

## 1. 選択ソートのイメージ

バラバラに並んだカードを想像してください。

1. 全体をじーっと見て、**一番小さい数字のカード**を探し出します。
2. そのカードを、**列の左端**にあるカードと交換します。
3. これで左端が「確定」しました。残りのカードの中で、また一番小さいのを探します。

この「一番いいものを選んで（選択）、正しい位置へ持っていく」という動作の繰り返しです。

---

## 2. 具体的な手順（4, 2, 5, 1 を並べ替える）

学生さんに教える際は、**「今、何を探しているのか」** を意識させるのがコツです。

**【1周目】全体から最小値を探す**

* [4, 2, 5, 1] の中で一番小さいのは **「1」**。
* 左端の「4」と「1」を交換します。
* [**1**, 2, 5, 4] → **「1」が確定！**

**【2周目】残りの [2, 5, 4] から最小値を探す**

* 一番小さいのは **「2」**。
* すでに左端（この範囲の）にあるので、交換なし（または自分自身と交換）。
* [1, **2**, 5, 4] → **「2」が確定！**

**【3周目】残りの [5, 4] から最小値を探す**

* 一番小さいのは **「4」**。
* 左端の「5」と「4」を交換します。
* [1, 2, **4**, 5] → **「4」が確定！**
* 残った「5」も自動的に確定。

---

## 3. バブルソートとの違い

ここが資料の重要ポイントになります。

* **バブルソート：** 隣同士を何度も入れ替えるので、**交換回数が多い。**
* **選択ソート：** 最小値を決めるまで交換しないので、**交換回数が少ない。**

ただし、どちらも「すべての組み合わせをチェック」することに変わりはないため、計算量（かかる時間）は同じ  です。

---

## 4. 特徴のまとめ

| 項目 | 特徴 |
| --- | --- |
| **考え方** | 最小値を見つけて、正しい位置へ移動させる。 |
| **メリット** | バブルソートに比べて、要素の入れ替え回数が劇的に少ない。 |
| **デメリット** | データの並び順に関わらず、必ず最後まで比較作業が必要。 |

---

## 資料作成のための英語表現

* **Selection Sort:** 基本選択法
* **Find the minimum element:** 最小値を見つける
* **Unsorted part:** 未整列の部分
* **Sorted part:** 整列済みの部分
* **Swap with the first element:** 先頭の要素と入れ替える

次は、これらと並んで「整列の基本3種」とされる**「基本挿入法（挿入ソート）」**について説明しましょうか？ それとも、そろそろ**アルゴリズムの効率（計算量）**について深掘りしてみますか？

## 実装

選択ソートのアルゴリズムに基づいたC言語の実装を作成しました。

このプログラムのポイントは、**「未整列の範囲の中から、まずは一番小さい値の『場所（添字）』を特定し、最後に一気に入れ替える」**という点にあります。

---

## C言語による選択ソートの実装

```c
#include <stdio.h>

void selectionSort(int arr[], int n) {
    int i, j, min_idx, temp;

    // 1つずつ「最小値を置く位置」を確定させていくループ
    for (i = 0; i < n - 1; i++) {
        
        // 現時点での最小値の場所を「i番目」と仮定する
        min_idx = i;
        
        // 残りの部分（i+1番目以降）から本当の最小値を探す
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) {
                min_idx = j; // もっと小さい値を見つけたら場所を更新
            }
        }

        // 見つけた最小値を、現在のi番目の要素と入れ替える（交換）
        // ※ すでにi番目が最小なら入れ替えは不要だが、処理を簡潔にするため毎回実行
        temp = arr[min_idx];
        arr[min_idx] = arr[i];
        arr[i] = temp;
    }
}

int main() {
    int data[] = {4, 2, 5, 1}; // 説明で使った例
    int n = 4;

    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    selectionSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生への解説ポイント

資料を作成する際、プログラムの動きをこのように分解して伝えると理解がスムーズです。

1. **変数 `min_idx` の役割**
* 選択ソートで最も重要な変数です。値そのものを入れ替える前に、**「どこに一番小さいのがあるか」という住所（インデックス）だけをメモ**していることを強調してください。


2. **入れ替えのタイミング**
* バブルソートは「見つけるたびに入れ替える」ので忙しいですが、選択ソートは**「1周回ってから、最後に1回だけ入れ替える」**ため、交換回数が少なくて済むことがコードからも分かります。


3. **内側のループの開始位置 `j = i + 1**`
* `i`番目より左側はすでに整列が完了しているので、探す必要がありません。「整列済みの列が左から伸びていく」様子を意識させます。



---

## 比較のヒント

バブルソートと選択ソートのコードを並べて、「`if`文（入れ替え）がどこにあるか」を比較させると、アルゴリズムの性格の違い（頻繁に入れ替える vs じっくり探して最後に入れ替える）がより明確になります。

次は、基本3種の中でも「実戦向き」な**挿入ソート**のC言語コードを作成しましょうか？それとも、アルゴリズムの全体像をまとめる作業を続けますか？


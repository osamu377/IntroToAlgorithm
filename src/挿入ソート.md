# 基本挿入法（挿入ソート）

「基本交換法（バブルソート）」「基本選択法（選択ソート）」と並んで、基本3種の中で最も実践的なのが、この **「基本挿入法（挿入ソート）」** です。

挿入ソートは、私たちが**「手持ちのトランプを並べ替えるときの動き」**に最も近いアルゴリズムです。

---

## 1. 挿入ソートのイメージ

バラバラに配られたトランプを左から順に手に取って、並べ替える場面を想像してください。

1. 左端の1枚を「整列済み」とみなします。
2. 次に、まだ見ていないカード（右側）から1枚取り出します。
3. そのカードを、すでに並んでいるカードの中に**「正しい位置はどこかな？」と探して差し込み（挿入）**ます。
4. これを最後の1枚まで繰り返します。

---

## 2. 具体的な手順（4, 2, 5, 1 を並べ替える）

「整列済みのグループ」が左からどんどん伸びていくイメージで進めます。

**【1周目】「2」をどこに入れるか決める**

* [**4**, | 2, 5, 1] ： 最初の「4」は整列済みと考えます。
* 次の「2」を取り出します。「4」と比べると「2」の方が小さいので、「4」の前に**挿入**します。
* [**2, 4**, | 5, 1] → 左側2枚が整列済み。

**【2周目】「5」をどこに入れるか決める**

* 次の「5」を取り出します。
* 整列済みの「4」と比べます。「5」の方が大きいので、そのまま（4の後ろに）**挿入**します。
* [**2, 4, 5**, | 1] → 左側3枚が整列済み。

**【3周目】「1」をどこに入れるか決める**

* 最後の「1」を取り出します。
* 「5」より小さい、「4」より小さい、「2」より小さい…と順番に見ていき、一番先頭に**挿入**します。
* [**1, 2, 4, 5**] → **完成！**

---

## 3. 挿入ソートのすごいところ（メリット）

実は、基本3種（交換・選択・挿入）の中で、挿入ソートには特筆すべき強みがあります。

* **「だいたい並んでいるデータ」にめちゃくちゃ強い**
すでに順番が整っているデータなら、「どこに挿入しようかな？」と探す手間がほとんど省けるため、バブルソートや選択ソートよりもずっと速く終わります。
* **オンライン処理ができる**
データが後から1つずつ追加されても、その都度「正しい場所」に差し込むだけでいいので、リアルタイムな処理に向いています。

---

## 4. 特徴のまとめ

| 項目 | 特徴 |
| --- | --- |
| **考え方** | 取り出した値を、整列済みの列の「適切な位置」に差し込む。 |
| **メリット** | 元のデータがある程度並んでいる場合、計算時間が非常に短い。 |
| **デメリット** | 逆順（大きい順）に並んでいるデータを並べ替えるときは、移動が多くて大変。 |

---

## 資料作成のための英語表現

* **Insertion Sort:** 基本挿入法
* **Sorted subarray:** 整列済みの部分列
* **Pick the next element:** 次の要素を取り出す
* **Shift elements to the right:** 要素を右にずらす（挿入するスペースを作るため）
* **Efficient for small data sets:** 小規模なデータセットに対して効率的

これで「整列の基本3種」がすべて揃いましたね！

学生向けの資料としては、最後に**「この3つの中で、どれが一番効率が良いか？（計算量の話）」**や、より高速な**「クイックソート」**などの発展形へ繋げると、非常にきれいな構成になります。次は計算量の解説に進みますか？

「トランプを正しい位置に差し込む」動きをプログラムにした、挿入ソートのC言語実装を作成しました。

このプログラムの最大の特徴は、**「今持っている値を、整列済みの列のどこに入れるべきか、後ろから順番に比較して隙間を作る」**という点です。

---

## C言語による挿入ソートの実装

```c
#include <stdio.h>

void insertionSort(int arr[], int n) {
    int i, j, key;

    // 2番目の要素（インデックス1）から順番に取り出す
    for (i = 1; i < n; i++) {
        key = arr[i]; // 現在注目している値（トランプから引いたカード）
        j = i - 1;

        /* 整列済みの部分（左側）を後ろから順に見ていく
           取り出した値（key）より大きい要素があれば、右に1つずらす
        */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // 右にずらす（コピーする）
            j = j - 1;
        }
        
        // 適切な位置が見つかったら、そこに値を差し込む
        arr[j + 1] = key;
    }
}

int main() {
    int data[] = {4, 2, 5, 1}; // 説明で使った例
    int n = 4;

    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    insertionSort(data, n);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生への解説ポイント

資料の中でコードを解説する際、以下の3点に注目させると、アルゴリズムの動きとプログラムが結びつきやすくなります。

1. **変数 `key` の役割**
* 差し込むための値を一時的に「手」に持っておく必要があります。これが `key` です。これをしておかないと、他の値を「ずらした」ときに元の値が上書きされて消えてしまいます。


2. **`while` ループの条件**
* `arr[j] > key` という条件は、「自分より大きい先輩たちがいる間は、右にどいてもらう」という意味です。
* `j >= 0` は、一番左端（先頭）まで到達した時に止めるための安全装置です。


3. **ずらす（Shift）と挿入（Insert）**
* `arr[j + 1] = arr[j]` は、隣へのコピーです。これにより隙間が作られます。
* ループが終わった後の `arr[j + 1] = key` が、ようやく見つけた「正しい居場所」にカードを置く瞬間です。



---

## 授業での「問いかけ」案

学生さんに、**「もし、最初からデータがきれいに並んでいたら、このプログラムはどう動くと思う？」**と聞いてみてください。

* **答え：** `while` ループの条件が最初から成立しないため、中身が一度も実行されません。
* **学び：** これにより、「挿入ソートは整列済みのデータに対して非常に高速である」という理論的な特徴を、コードレベルで実感させることができます。

次は、より高度な**シェルソートやクイックソート**のコード作成に挑戦しますか？ それとも、一旦ここまでの内容を整理した**学生向け配布プリントの構成案**などを作成しましょうか？




「クイックソート」と並んで、非常に効率的で重要なアルゴリズムが**「マージソート（併合ソート）」**です。

クイックソートが「適当な基準で分ける」のに対し、マージソートは**「きっちり半分に分け、あとで綺麗に合体させる」**という、非常に几帳面なアルゴリズムです。

---

## 1. マージソートの基本戦略

マージソートは、大きく分けて2つのステップを繰り返します。

1. **分割 (Divide):** データを要素が1つになるまで、ひたすら半分に分割し続けます。
2. **併合 (Merge):** 分割されたデータを、**順番を守りながら合体（マージ）**させていきます。

---

## 2. 具体的な手順（4, 2, 5, 1 を並べ替える）

### ステップ1：バラバラに解体する

* `[4, 2, 5, 1]` を半分に → `[4, 2]` と `[5, 1]`
* さらに半分に → `[4]` `[2]` `[5]` `[1]`
（これで全員が1人ぼっちになりました。1つの要素は、それ自体が「整列済み」と言えます）

### ステップ2：順番を守って合体させる

ここからが「マージ」の本領発揮です。

* `[4]` と `[2]` を合体： 2つを比べて小さい順に並べる → `[2, 4]`
* `[5]` と `[1]` を合体： 2つを比べて小さい順に並べる → `[1, 5]`
* `[2, 4]` と `[1, 5]` を合体：
1. それぞれの先頭（2と1）を比べる → **1** を採用
2. 残った先頭（2と5）を比べる → **2** を採用
3. 残った先頭（4と5）を比べる → **4** を採用
4. 最後に残った **5** を採用


* 完成： `[1, 2, 4, 5]`

---

## 3. マージソートのメリット・デメリット

| 項目 | 特徴 |
| --- | --- |
| **安定性** | **非常に安定している。** クイックソートと違い、データの並び順が悪くても速度が落ちません。 |
| **計算量** | 常に 。どんなにバラバラなデータでも、一定の速さを保証します。 |
| **弱点** | **メモリを多く使う。** 合体作業をするために、一時的に別の「作業スペース（予備の配列）」が必要になります。 |

---

## 4. クイックソートとの違い（学生への説明ポイント）

資料を作成する際、この2つの「王様」の違いをまとめると理解が深まります。

* **クイックソート：** * 最初に「仕分け（パーティション）」をして、あとで繋げる。
* 準備は大変だけど、合体は楽。
* **「現場で仕分けるタイプ」**


* **マージソート：** * とにかくバラバラにしてから、合体させるときに整列する。
* 準備は楽だけど、合体（マージ）が一番重要。
* **「後からきっちりまとめるタイプ」**



---

## 資料作成のための英語表現

* **Merge Sort:** マージソート（併合ソート）
* **Divide and Conquer:** 分割統治法（マージソートもこれに該当します）
* **Merge:** 併合（2つの整列済みリストを1つにまとめること）
* **Recursive call:** 再帰呼び出し
* **Stable sort:** 安定ソート（同じ値の順序が入れ替わらないこと）

---

### 次のステップへの提案

これで代表的なソートアルゴリズムが出揃いました。
ここまで学んできた**「バブル・選択・挿入・シェル・クイック・マージ」の6種類を1枚にまとめた「比較表」**のテキストデータを作成しましょうか？

それとも、試験で「マージソート」とセットでよく出る**「スタック」や「キュー」**といったデータの入れ物の話に移りますか？

## 実装

マージソートの実装は、クイックソートと同様に**再帰**を使用しますが、最大の特徴は「バラバラにしたものを合体（マージ）させる際に整列させる」という点です。

合体作業（マージ）を行う際、一時的にデータを避難させるための**「作業用配列」**が必要になることが、他のソートとの大きな違いです。

---

## C言語によるマージソートの実装

```c
#include <stdio.h>

// 作業用の配列（データの最大数に合わせて用意）
int temp[100];

// 2つの整列済み範囲を1つに合体させる関数
void merge(int arr[], int left, int mid, int right) {
    int i = left;      // 左側グループの先頭
    int j = mid + 1;   // 右側グループの先頭
    int k = 0;         // 作業用配列の添字

    // 左右の要素を比較して、小さい方を順に作業用配列へコピー
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
        }
    }

    // 左側に残った要素をコピー
    while (i <= mid) temp[k++] = arr[i++];
    // 右側に残った要素をコピー
    while (j <= right) temp[k++] = arr[j++];

    // 作業用配列から元の配列へ書き戻す
    for (i = 0; i < k; i++) {
        arr[left + i] = temp[i];
    }
}

// マージソートの本体（分割を担当）
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = (left + right) / 2; // 真ん中を計算

        mergeSort(arr, left, mid);      // 左半分を分割
        mergeSort(arr, mid + 1, right); // 右半分を分割

        merge(arr, left, mid, right);   // 最後に合体（マージ）
    }
}

int main() {
    int data[] = {4, 2, 5, 1};
    int n = 4;

    printf("ソート前: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    mergeSort(data, 0, n - 1);

    printf("ソート後: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");

    return 0;
}

```

---

## 学生への解説ポイント

1. **「分割」と「統合」の役割分担**
* `mergeSort` 関数：配列を真ん中でバッサリ切り続ける役割です。
* `merge` 関数：バラバラになった数字を、**「2つの整列済みリストを1つにまとめる」**というルールで綺麗に並べ直す役割です。


2. **一時的な作業スペース（`temp`）**
* マージソートは、合体作業中に元の配列の値を上書きしてしまうため、一時的に避難させるための「作業台」が必要です。これがメモリを余分に使う理由です。


3. **比較のロジック**
* `while` ループの中で、左の山と右の山の「先頭」だけを見比べて、小さい方を採用しています。これはトランプの山を2つ作り、上のカードをめくりながら小さい方を新しい山に積んでいく動きと同じです。



---

## 授業でのヒント：安定性の証明

学生さんに、**「マージソートは、なぜ同じ数字の順番が入れ替わらない（安定な）の？」**と聞かれたら、コード内の以下の部分を指し示してください。

* `if (arr[i] <= arr[j])`
* ここで `<=`（以下）としているため、左側にあった同じ値が優先的に採用されます。これが「安定性」を支える重要な一行であることを伝えると、アルゴリズムの繊細さが伝わります。

---

### 次のステップへの提案

ソートアルゴリズムの集大成として、以下のいずれかに進むのがおすすめです。

1. **ヒープソート**のC言語実装を作成する（木構造の理解が必要になるので、少し難易度が上がります）。
2. **実行時間の計測**をコードに組み込んでみる（1万個のランダムな数字を作り、バブルソートとクイックソートでどれくらい時間が違うか、`time.h` を使って実験する）。
3. ソート編は一旦終了し、**二分探索（バイナリサーチ）**などの「探索」のコードへ進む。

どれに興味がありますか？